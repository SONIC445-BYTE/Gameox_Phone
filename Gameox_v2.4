<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neuro-Motor Hub Mobile (Patched)</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1632432244/camera_utils.js"></script>

    <style>
        body { margin: 0; background: #000; color: #00ff00; font-family: 'Courier New', monospace; overflow: hidden; touch-action: none; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; }
        video { display: none; } /* Hidden video element */
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }
        #ui-top { position: absolute; top: 20px; width: 100%; text-align: center; font-weight: bold; font-size: 14px; text-shadow: 2px 2px #000; pointer-events: auto;}
        
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 50;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        button {
            background: #00ff00; color: #000; border: none; padding: 15px 30px;
            font-family: 'Courier New', monospace; font-size: 20px; font-weight: bold;
            cursor: pointer; margin-top: 20px;
        }
        #debug-log {
            position: absolute; bottom: 10px; left: 10px; font-size: 10px; color: #555;
            z-index: 100; max-width: 80%;
        }
    </style>
</head>
<body>

<div id="container">
    <video id="input_video" playsinline></video>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="ui-top">NEURO-LINK STATUS: <span id="status">OFFLINE</span></div>
    </div>

    <div id="start-screen">
        <h1>NEURO-MOTOR HUB</h1>
        <p>Camera Access Required</p>
        <button id="start-btn">INITIALIZE SYSTEM</button>
    </div>

    <div id="debug-log">Log: System Ready.</div>
</div>

<script>
/** * --- CONFIG & UTILS ---
 */
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('gameCanvas');
const ctx = canvasElement.getContext('2d');
const statusEl = document.getElementById('status');
const debugEl = document.getElementById('debug-log');
const startScreen = document.getElementById('start-screen');

function log(msg) { debugEl.innerText = "Log: " + msg; }

let gameState = "IDLE"; // IDLE, BOOT, CALIBRATE, PLAYING, GAMEOVER
let score = 0, lives = 3, bootTimer = 0, romProgress = 0;
let handX = 0, handY = 0, pinching = false;
let eyeClosed = false, currentEyeDist = 0; // Added for debug
let enemies = [], bullets = [], tremorData = [], reactionTimes = [];
let lastShotTime = 0;

// Audio Context (Created but suspended until interaction)
let audioCtx;

function resize() {
    canvasElement.width = window.innerWidth;
    canvasElement.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function initAudio() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playSfx(freqStart, freqEnd, duration) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.frequency.setValueAtTime(freqStart, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(freqEnd, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
}

/** * --- MEDIAPIPE AI MODELS ---
 */
// Using specific CDN paths helps reliability
const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}` });
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 }); // Lowered confidence slightly for speed

const faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}` });
faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5 });

// Hand Logic
hands.onResults((results) => {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        statusEl.innerText = "HAND LOCKED";
        const lm = results.multiHandLandmarks[0];
        
        // Mirror effect fix: (1 - x)
        const targetX = (1 - lm[8].x) * canvasElement.width;
        const targetY = lm[8].y * canvasElement.height;

        // Smoothing
        handX += (targetX - handX) * 0.4;
        handY += (targetY - handY) * 0.4;

        // Pinch Calculation
        const dist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
        pinching = dist < 0.06;

        if (gameState === "PLAYING") {
            tremorData.push(Math.abs(targetX - handX) + Math.abs(targetY - handY));
            if (tremorData.length > 60) tremorData.shift();
        }
    } else { 
        statusEl.innerText = "SEARCHING HAND..."; 
    }
});

// Face Logic
faceMesh.onResults((results) => {
    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const lm = results.multiFaceLandmarks[0];
        // Left eye indices: Top 159, Bottom 145
        const top = lm[159]; 
        const bottom = lm[145];
        
        // Calculate raw distance
        const eyeDist = Math.hypot(top.x - bottom.x, top.y - bottom.y);
        currentEyeDist = eyeDist.toFixed(3); // Store for debug display
        
        // ADJUSTED THRESHOLD: Increased to 0.025 (was 0.012)
        eyeClosed = eyeDist < 0.025;
    }
});

// Camera Setup
let camera;
function startCamera() {
    log("Starting Camera...");
    camera = new Camera(videoElement, {
        onFrame: async () => {
            // Optimization: Only run face mesh during Boot/Calibrate
            if (gameState === "BOOT" || gameState === "CALIBRATE") {
                await faceMesh.send({image: videoElement});
            }
            // Always run hands
            await hands.send({image: videoElement});
        },
        width: 640, height: 480 
    });
    camera.start()
        .then(() => log("Camera Started"))
        .catch(e => log("Camera Error: " + e));
}

/** * --- MAIN GAME ENGINE ---
 */
document.getElementById('start-btn').addEventListener('click', () => {
    startScreen.style.display = 'none';
    initAudio();
    audioCtx.resume();
    startCamera();
    gameState = "BOOT";
});

function drawLoop() {
    ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    // Scanline Effect
    ctx.fillStyle = "rgba(0, 255, 0, 0.05)";
    ctx.fillRect(0, (Date.now() / 5) % canvasElement.height, canvasElement.width, 2);

    if (gameState === "BOOT") {
        bootTimer++;
        ctx.fillStyle = "#0f0";
        ctx.font = "16px Courier New";
        ctx.fillText("> SYSTEM INITIALIZING...", 30, 100);
        
        if(bootTimer > 30) ctx.fillText("> HAND TRACKERS: CONNECTED", 30, 130);
        if(bootTimer > 60) ctx.fillText("> OCULAR SCANNER: READY", 30, 160);
        
        if(bootTimer > 90) {
            ctx.fillStyle = "#ff0";
            ctx.textAlign = "center";
            ctx.fillText("BLINK EYES TO START", canvasElement.width/2, canvasElement.height/2);
            
            // Debug Value for User
            ctx.fillStyle = "#aaa";
            ctx.font = "12px Courier New";
            ctx.fillText(`EYE GAP: ${currentEyeDist} (Needs < 0.025)`, canvasElement.width/2, canvasElement.height/2 + 30);
            
            ctx.textAlign = "left";

            if(eyeClosed) {
                playSfx(400, 800, 0.2);
                gameState = "CALIBRATE";
            }
        }
    }

    else if (gameState === "CALIBRATE") {
        ctx.strokeStyle = "#0ff";
        ctx.strokeRect(50, canvasElement.height/2, canvasElement.width-100, 20);
        ctx.fillStyle = "#0ff";
        ctx.fillRect(52, canvasElement.height/2 + 2, romProgress * (canvasElement.width-104), 16);
        ctx.fillText("PINCH FINGERS TO FILL BAR", 50, canvasElement.height/2 - 20);

        if (pinching) romProgress += 0.02; // Faster calibration
        if (romProgress >= 1) {
            playSfx(800, 1200, 0.3);
            gameState = "PLAYING";
            score = 0; lives = 3; enemies = []; bullets = [];
        }
    }

    else if (gameState === "PLAYING") {
        const now = Date.now();

        // Shoot
        if (pinching && now - lastShotTime > 300) {
            bullets.push({x: handX, y: handY});
            lastShotTime = now;
            playSfx(600, 200, 0.1);
        }

        // Bullets
        bullets.forEach((b, i) => {
            b.y -= 15;
            ctx.fillStyle = "#0ff";
            ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
            if(b.y < 0) bullets.splice(i,1);
        });

        // Enemies
        if (Math.random() < 0.02 + (score/2000)) {
            enemies.push({ x: Math.random() * (canvasElement.width-40) + 20, y: -30, speed: 2 + (score/100), spawnTime: now });
        }

        enemies.forEach((e, i) => {
            e.y += e.speed;
            ctx.fillStyle = "#f33";
            ctx.beginPath(); ctx.arc(e.x, e.y, 20, 0, Math.PI*2); ctx.fill();

            // Hit detection
            bullets.forEach((b, bi) => {
                if(Math.hypot(e.x - b.x, e.y - b.y) < 25) {
                    enemies.splice(i, 1);
                    bullets.splice(bi, 1);
                    score += 10;
                    reactionTimes.push(Date.now() - e.spawnTime);
                    playSfx(150, 50, 0.2);
                }
            });

            if(e.y > canvasElement.height) {
                enemies.splice(i,1); lives--;
                if(lives <= 0) gameState = "GAMEOVER";
            }
        });

        // Reticle
        ctx.strokeStyle = pinching ? "#f00" : "#0f0";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(handX, handY, 25, 0, Math.PI*2);
        ctx.moveTo(handX - 35, handY); ctx.lineTo(handX + 35, handY);
        ctx.moveTo(handX, handY - 35); ctx.lineTo(handX, handY + 35);
        ctx.stroke();

        // UI
        ctx.fillStyle = "#0f0";
        ctx.fillText(`SCORE: ${score}`, 20, 50);
        ctx.fillStyle = "#f00";
        ctx.fillText(`LIVES: ${lives}`, canvasElement.width - 100, 50);
    }

    else if (gameState === "GAMEOVER") {
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect(0,0, canvasElement.width, canvasElement.height);
        
        ctx.textAlign = "center";
        ctx.fillStyle = "#0f0";
        ctx.fillText("--- DIAGNOSTIC COMPLETE ---", canvasElement.width/2, 100);

        const avgReaction = reactionTimes.length ? Math.round(reactionTimes.reduce((a,b)=>a+b)/reactionTimes.length) : 0;
        
        ctx.fillStyle = "#fff";
        ctx.fillText(`AVG REACTION: ${avgReaction}ms`, canvasElement.width/2, 180);
        ctx.fillText(`FINAL SCORE: ${score}`, canvasElement.width/2, 210);

        ctx.fillStyle = "#ff0";
        ctx.fillText("TAP SCREEN TO RE-BOOT", canvasElement.width/2, 300);
        ctx.textAlign = "left";
    }

    requestAnimationFrame(drawLoop);
}

window.addEventListener('touchstart', () => {
    if(gameState === "GAMEOVER") location.reload();
});

drawLoop();
</script>
</body>
</html>
